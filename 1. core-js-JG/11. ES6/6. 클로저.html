<!DOCTYPE html>
<html lang="ko">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Document</title>
</head>

<body>

  <script>
    /*
    let count = 0; // 전역 변수
    
    // 카운트를 증가시키는 함수
    const increase = () => /*return 생략*/ //++count

    /*

    ++count; //++count 올리고 난 후 대입

    console.log(increase()); //1
    console.log(increase()); //2
    count = 999;
    console.log(increase()); //1002
    */

    //값 유지는 가능하지만 전역변수 특성상 어느 영역에서나 접근이 가능하기 때문에
    //값 변경의 가능성이 항상 존재

    /*
    const increase = () => {
      let count = 0; //지역 변수
      return ++count;
    }

    console.log(increase()); //1 지역 변수는 해당 라인에서만
    console.log(increase()); //1
    count = 999;
    console.log(increase()); //1

    //함수 호출이 종료되면 소멸하는 지역변수 특성 때문에 값 유지X
    */


    /*
    //카운트를 증가시키는 함수를 리턴하는 클로저를 생성
    const increaseClosure = () => {
      let count = 0;
      // return function() { //원형대로 적음
      //   return ++count;
      // }
      return () => ++count; // =>함수

    }
    
    const increase = increaseClosure();
    console.log(increase);
    console.log(increase);
    //count = 999; 지역변수와 다르게 지역변수도 이용불가 : 값은 지키면서, 외부에서 접근 불가
    console.log(increase); //3?
    */
    
    // 즉시 실행 함수 : 1회성 호출 함수를 만들 때 주로 사용.
    const increase = (()=>{
      let count = 0;
      return() => ++count;
    })();

    console.log(increase());
    console.log(increase());
    count = 999;
    console.log(increase());
    
    /*
    클로저 함수를 사용하는 목적
      1. 외부로 값을 보호하면서 데이터를 계속 유지시키기 위한 방법으로 사용
      2. 모듈화에 유리 -> 함수의 재사용성 극대화 하여, 다양한 로직에 대응할 수 있는 코드 작성 가능 
    */



  </script>



</body>

</html> 